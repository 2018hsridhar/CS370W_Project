// need to show Dr. Vouga this stuff - take out I/O aspect here
//#include <igl/readOFF.h>
#include <igl/readOBJ.h>
//#define IGL_NO_CORK
//#undef IGL_STATIC_LIBRARY
#include <igl/copyleft/cgal/mesh_boolean.h>
#include <igl/viewer/Viewer.h>

#include <Eigen/Core>
#include <iostream>

#include "tutorial_shared_path.h"

Eigen::MatrixXd VA,VB,VC;
Eigen::VectorXi J,I;
Eigen::MatrixXi FA,FB,FC;
igl::MeshBooleanType boolean_type(igl::MESH_BOOLEAN_TYPE_INTERSECT);

const char * MESH_BOOLEAN_TYPE_NAMES[] =
{
  "Union",
  "Intersect",
  "Minus",
  "XOR",
  "Resolve",
};

//void update(igl::viewer::Viewer &viewer)
void update()
{
  //std::cout << "before bool operations app" << std::endl;
	// getting thrown a <Input mesh is not orientable!> error here! 
    // error is being thrown under /cgal/propagate_winding_numbers.cpp. Winding number is off for the planes case. Need to try cubes instead? 
  igl::copyleft::cgal::mesh_boolean(VA,FA,VB,FB,boolean_type,VC,FC,J);
  //std::cout << "after bool operations app" << std::endl;
  Eigen::MatrixXd C(FC.rows(),3);
  for(size_t f = 0;f<C.rows();f++)
  {
    if(J(f)<FA.rows())
    {
      C.row(f) = Eigen::RowVector3d(1,0,0);
    }else
    {
      C.row(f) = Eigen::RowVector3d(0,1,0);
    }
  }
  /*
  viewer.data.clear();
  viewer.data.set_mesh(VC,FC);
  viewer.data.set_colors(C);
  */ 
  std::cout<<"A "<<MESH_BOOLEAN_TYPE_NAMES[boolean_type]<<" B."<<std::endl;
}

/*
bool key_down(igl::viewer::Viewer &viewer, unsigned char key, int mods)
{
  switch(key)
  {
    default:
      return false;
    case '.':
      boolean_type =
        static_cast<igl::MeshBooleanType>(
          (boolean_type+1)% igl::NUM_MESH_BOOLEAN_TYPES);
      break;
    case ',':
      boolean_type =
        static_cast<igl::MeshBooleanType>(
          (boolean_type+igl::NUM_MESH_BOOLEAN_TYPES-1)%
          igl::NUM_MESH_BOOLEAN_TYPES);
      break;
    case '[':
      viewer.core.camera_dnear -= 0.1;
      return true;
    case ']':
      viewer.core.camera_dnear += 0.1;
      return true;
  }
  update(viewer);
  return true;
}
*/

int main(int argc, char *argv[])
{
  using namespace Eigen;
  using namespace std;
  //igl::readOFF(TUTORIAL_SHARED_PATH "/cheburashka.off",VA,FA);
  //igl::readOFF(TUTORIAL_SHARED_PATH "/decimated-knight.off",VB,FB);
	// note :: your input meshes MUST be orientable. Else err
	// so I can get the intersection ... but how to get two pieces not part of intersection?A
	// wiith the plane ... intersection and unions do NOT work as expected. Kinda weird!
  // #NOTE ::  do my meshes have to be water tight? I think that could be an issue!
	// Seems to work when both are "cow.off". How about both "camelHead.off"?
	// in the cow ( contians bunny in hollow interior ) ---> why is the bunny the result of the intersection? Seems kinda weird IMO!


// try out <circle, cube > obj files. this might be more useful!

  igl::readOBJ(TUTORIAL_SHARED_PATH "/circle.obj",VB,FB);
  igl::readOBJ(TUTORIAL_SHARED_PATH "/cube.obj",VB,FB);
  //igl::readOFF(TUTORIAL_SHARED_PATH "/bunny.off",VA,FA);
  //igl::readOFF(TUTORIAL_SHARED_PATH "/cow.off",VB,FB);
  //igl::readOFF(TUTORIAL_SHARED_PATH "/planexy.off",VB,FB);
  // Plot the mesh with pseudocolors
  //igl::viewer::Viewer viewer;

  // Initialize
  //update(viewer);
  update();
  igl::writeOFF(TUTORIAL_SHARED_PATH "/boolean.off", VC, FC);

/*
  viewer.core.show_lines = true;
  viewer.callback_key_down = &key_down;
  viewer.core.camera_dnear = 3.9;
  cout<<
    "Press '.' to switch to next boolean operation type."<<endl<<
    "Press ',' to switch to previous boolean operation type."<<endl<<
    "Press ']' to push near cutting plane away from camera."<<endl<<
    "Press '[' to pull near cutting plane closer to camera."<<endl<<
    "Hint: investigate _inside_ the model to see orientation changes."<<endl;
  viewer.launch();
*/
}
