// PURPOSE :: a greedy surface reconstruction algorithm, from 2 range images, based of closest distances between boundary vertices

#include "interpSurface.h"
#include "remesh.h"
#include "glob_defs.h"
#include <igl/writeOFF.h>
using namespace Eigen;  
using namespace igl;
using namespace std;

// #TODO :: if time available, convert main() to a testing method
int main(int argc, char *argv[])
{

/*
	std::vector<Eigen::Vector2i> visited;
	// some pseudo edge-data, to try out
	std::vector<std::pair<int,int>> data;
	int arr[] = {1,2,3,4,4,4,6};
	int arr1[] = {108,108,108,108,107,106,6};
	int n = sizeof(arr) / sizeof(arr[0]);

	// enter values in vec, of pairs
	for (unsigned int i = 0; i < n; ++i)
	{
		data.push_back (std::make_pair(arr[i], arr1[i]));
	}

	// print thsi vector
	for(unsigned int i = 0; i < n; ++i)
	{
		//std::cout << data[i].first << " " << data[i].second << std::endl;
		Eigen::Vector2i local(data[i].first,data[i].second);
		visited.push_back(local);
	}

	Eigen::Vector2i fail1(4,108);
	Eigen::Vector2i fail2(6,6);

	// check to see that both of these are located in the vector of edges
	for(std::vector<Eigen::Vector2i>::iterator it = visited.begin(); it != visited.end(); ++it)
	{
		Eigen::Vector2i myEdge = *it;	
		std::cout << myEdge(0) << " " << myEdge(1) << std::endl;
		if(fail2 == myEdge)
		{
			std::cout << "Met common edge!" << std::endl;
			std::cout << "E1 = " << fail2(0) << " " << fail2(1) << std::endl;
			std::cout << "E2 = " << myEdge(0) << " " << myEdge(1) << std::endl;
		}
	}	
*/

	// LOAD IN MESHES 
	std::cout << "Executing (TEST) for offset surface generation." << std::endl;

	struct Mesh
	{
		Eigen::MatrixXd V; 
		Eigen::MatrixXi F;
	} scan1,scan2,scene, remeshed;

	if(!readOFF(GLOBAL::interpSurfGenScan1File,scan1.V,scan1.F)) {
		std::cout << "Failed to load partial scan one." << std::endl;
	} 

	if(!readOFF(GLOBAL::interpSurfGenScan2File,scan2.V,scan2.F)) {
		std::cout << "Failed to load partial scan two." << std::endl;
	}

	INTERP_SURF::generateOffsetSurface(scan1.V,scan1.F,scan2.V,scan2.F, scene.V,scene.F);

	// check the normals here ... only for faces that possess a common edge!
	// correctly reorder!


	std::cout << "Printing bad mesh" << std::endl;
	std::string bad_mesh_fName = "badInterpSurface.off";
	igl::writeOFF(bad_mesh_fName,scene.V,scene.F);


	double rel = REMESH::avgEdgeLenInputMeshes(scan1.V, scan1.F, scan2.V, scan2.F);
	std::cout << "Remesh avg edge len = [" << rel << "]\n";
	REMESH::remeshSurface(scene.V,scene.F,remeshed.V,remeshed.F, rel);

	//  SETUP LibIgl Viewer 
	igl::viewer::Viewer viewer;
    viewer.data.set_mesh(scene.V, scene.F); 
	viewer.launch();
	viewer.data.set_mesh(remeshed.V, remeshed.F); 
}

